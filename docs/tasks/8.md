Create a plan to make a class called "TreeView" that creates and manages the display of a phylogenetic tree in an SVG element, adapting the code in `src/index.js`.
The constructor should take a `TreeState` object and containing SVG element as input and respond to changes in the TreeState object by updating the tree.
Prioritize speed by modifying existing elements after they have been initially created and only recreate elements when needed or it would greatly simplify otherwise complicated code.

## Implementation plan

### Step 1: Define TreeView class structure and initialization

Create a new file `src/TreeView.js` with a class that:
- Takes a `TreeState` instance and an SVG container element in the constructor
- Subscribes to TreeState events (e.g., 'coordinateChange', 'layoutChange', and all the aesthetic changes named XChanges, where X is the name of the aeasthetic)
- Initializes SVG layers for branches, nodes, and labels
- Stores references to D3 selections for efficient updates
- Maintains internal state for transitions and animations

Key properties to track:
- `state`: Reference to the TreeState instance
- `svg`: The main SVG container
- `layers`: Object containing references to branch and node layers
- `selections`: Object containing D3 selections for reusable elements
- `currentTransform`: Current zoom/pan transform
- `transitionDuration`: Duration for animations (from options)
- `isTransitioning`: Flag to prevent overlapping transitions

### Step 2: Implement SVG layer initialization

Create method `initializeLayers()` that sets up:
- `branchLayer`: Group for all branch paths
- `nodeLayer`: Group for node shapes and labels
- `legendLayer`: Group for scale bars and legends within the tree

Each layer should be created once and reused for all updates.

### Step 3: Create branch rendering system

Implement methods:
- `updateBranches(transition = true)`: Main method to update all branches
- `createBranchGroup(linkData)`: Creates initial branch group with offset and extension paths
- `updateBranchPaths(selection, transition)`: Updates path geometry based on layout
- `getBranchPath(link, pathType)`: Generates SVG path string for 'offset' or 'extension'

Use D3's data join pattern with stable node IDs:
- Enter: Create new branch groups at parent position
- Update: Transition to new positions
- Exit: Collapse back to parent and remove

Store branch selections in `this.selections.branches` for efficient updates.

### Step 4: Create node rendering system

Implement methods:
- `updateNodes(transition = true)`: Main method to update all nodes
- `createNodeGroup(nodeData)`: Creates initial node group with shape, labels
- `updateNodePositions(selection, transition)`: Updates node transforms
- `updateNodeLabels(selection)`: Updates label text, colors, and sizes
- `updateNodeShapes(selection)`: Updates triangle shapes for collapsed nodes
- `updateCollapsedIndicators(selection)`: Updates collapsed root lines and labels

Use D3's data join with node IDs for efficient updates.
Store node selections in `this.selections.nodes`.

Create helper methods:
- `getLabelRotation(node)`: Returns rotation angle based on layout and position
- `getLabelAnchor(node)`: Returns text-anchor value based on node type and position
- `getLabelOffset(node)`: Returns x/y offsets for label positioning
- `isLeftSide(node)`: Determines if node is on left side in circular layout

Handle special cases:
- Instant 180Â° flip for labels transitioning between layouts
- Different anchor points for interior vs leaf nodes
- Flipped offsets for left-side nodes in circular layout

### Step 5: Create transition management system

Implement methods:
- `createTransition()`: Creates a D3 transition with appropriate duration
- `handleTransitionStart()`: Sets transitioning flag and hides elements as needed
- `handleTransitionEnd()`: Clears flag, shows new elements, updates UI
- `cancelTransitions()`: Cancels any in-progress transitions

Manage transition timing:
- Main transition for position/size changes
- Delayed fade-in for newly expanded subtrees
- Instant updates for layout-independent properties

